Багатопоточність

Створити проект JavaFX і назвати fxml файл Fibonacci, а його контроллер - FibonacciController.

Використовуючи Scene Builder створити графічний інтерфейс програми з текстовим полем, надписом для виведення результату і кнопкою.

[0window.png]

Задати такі значення параметрів для елементів керування і додати їх у контроллер:
для текстового поля fx:id - input
для кнопки onAction - calculate
для результату fx:id - result

Додати їх у контроллер.

В обробнику calculate реалізувати обчислення числа Фібоначчі з введеним порядковим номером. Перевірити роботу програми.

Щоб не доводилось використвоувати для перевірки дуже великі числа, можна штучно сповільнити алгоритм додавши у нього пустий цикл
for (long j=0;j<100000000;j++);

[1controller.java]
Результуючий код контроллера.

Тепер можна побачити, що до завершення обчислень інтерфейс програми повністю блокується. Це відбувається тому що вся програма JavaFX виконується в одному потоці. Тому усі тривалі операції (складні обчислення, завантаження великого файлу) потрібно виносити з головного потоку програми. Це спричиняє проблему тому що компоненти JavaFX не пристосовані до спільного доступу (non thread safe) і безпечно працювати з ними можна тільки з головного потоку. Реалізація такого доступу стандартними методами Java є складною і тому у склад JavaFX входить пакет javafx.concurrent з класами, що полегшують цю задачу. Основним з цих класів є Task. Наслідуючи його треба створити власний клас FibonacciTask

[2task.java]
FibonacciTask.java

При наслідуванні Task вказуєть тип результату. В даному випадку це Long. Вхідні параметри передаються через конструктор класу. Обчислення числа Фібоначчі перенесено з контролллера у метод call і результат обчислень просто повертається з нього через оператор return.

Контроллер при цьому необхідно видозмінити так

[2controller.java]
FibonacciController.java

Як видно з коду при натисканні на кнопку спочатку створюється об'єкт класу FibonacciTask і в конструктор передається порядковий номер елемента послідовності. Потім прив'язується обробник до події onSucceeded, який буде виконано після завершення задачі. Всередині обробника зчитується результат виконання задачі через метод task.getValue(), конвертується в рядок (оскільки дана задача повертає значення типу Long) і записується в надпис result.

Після задання параметрів задачі створюється об'єкт класу Thread (з стандартної бібліотеки Java). Задання параметру thread.setDaemon(true); потрібне щоб незавершений потік не блокував закриття всієї програми (по замовчуванню перед виходом програма чекає завершення всіх своїх потоків). І далі задача запускається на виконання в окремому потоці через метод thread.start().

Якщо запустити програму тепер - то обчислення більше не заморожує інтерфейс користувача. Можливо навіть обчислювати кілька значень паралельно швидко вводячи число в поле і натискаючи кнопку. Але оскільки всі задачі записують результат у той самий елемент форми - то нові значення перезаписують старі. Щоб це виправити і краще побачити одночасну роботу багатьох потоків видалимо з форми надпис result і замість нього додамо таблицю (TableView) та задамо для її параметра if:id значення resultTable. Поки що в таблиці буде тільки один стовбець, для нього потрібно задати fx:id значення resultCol.

[3window.png]

Далі потрібно додати їх у контроллер у такому вигляді
	@FXML TableView<FibonacciTask> resultTable;
	@FXML TableColumn<FibonacciTask, Long> resultCol;
Такий опис вказує, що у таблиця призначена для відображення об'єктів класу FibonacciTask. А у стовпці буде виводитись значення типу Long (при виведенні воно автоматично перетвориться в рядок з використанням стандартного методу toString для цілих чисел).

Щоб відображати результати в таблиці ми використаємо те, що результат задачі є JavaFX властивістю (property) класу Task. А значить TableView може спостерігати за його значенням і оновлюватись автоматично. Для цього треба тільки встановити відповідність між властивістю класу та стовпцем таблиці використовуючи метод setCellValueFactory. Ця прив'язка буде виконуватись одразу при відкритті вікна у методі initialize.

При такому підході обробник події більше не потрібен і об'єкт task можна просто додати в таблицю перед запуском потоку.

[3controller.java]
Результуючий клас контроллера.

Тепер при натисканні на кнопку у таблицю одразу додається новий рядок а коли задача поверне результат обчислень - то він автоматично виводиться у відповідну клітинку.

Для зручності перевірки можна додати у форму ще одну кнопку і обробник натискання на неї, який збільшує значення у полі input на одиницю і одразу запускає метод calculate().

[4window.png]

Клас Task має інші параметри крім value, який зберігає результат виконання. Зараз ми використаємо параметр title щоб відображати в таблиці порядковий номер числа Фібоначчі, яке обчислюється в даній задачі. Всередині класу FibonacciTask його можна змінювати за домомогою методу updateTitle (цей параметр має рядковий тип, тому число потрібно сконвертувати). Прив'язка параметру title до стовпця таблиці відбувається по аналогії до value.

Також клас Task має параметр message, який можна використовувати для передачі текстових повідомлень в головний процес. Додамо в таблицю стовбець statusCol а всередині класу FibonacciTask методом updateMessage будемо передавати відображати колистувачу статус виконання задачі.

[5windows.png]

Останній з стандартних параметрів класу Task це progress - дійсне число в межах від 0 до 1, в якому задача може передавати відсоток своєї завершеності. Метод updateProgress дещо відрізняється від аналогічних для решти параметрів. У нього передаються два числа (цілі або дійсні) і перше вказує на кількість завершених дій, а друге - загальну кількість дій, які необхідно виконати. Наприклад при завантаженні файлу з мережі у другому параметрі можна передавати загальний розмір файлу, а в першому - кількість вже завантажених байтів. Приведення параметру progress до потрібних меж буде виконано автоматично.

Модифікуємо метод call так, щоб updateProgress викликався на кожній ітерації циклу. В контроллері прив'язуємо паарметр progress до нового стовпця таблиці методом setCellValueFactory. Якщо запустити програму тепер - то прогрес буде виводитись у вигляді дійсного числа. Для більш наочного відображення можна відображати його у вигляді елементу ProgressBarTableCell (спеціальний індикатор прогресу, розрахований на відображення в TableView). Для його прив'язки використовується метод setCellFactory. Результуючий код контроллера і задачі.

[6controller.java]
[6task.java]
[6window.java]

Тепер видно, що скільки б задач ми не запускали, всі вони виконуються паралельно. Але комп'ютер має обмежену кількість ядер тому при великій кількості потоків операційна система просто періодично перемикається між ними і тому швидкодія від цього не зростає. А постійне створення та знищення потоків ще більше сповільнює виконання. Тому замість того щоб створювати потік на кожну задачу можна скористатись класом java.util.concurrent.ExecutorService, який призначений для автоматичного керування потоками. А саме - використаємо його реалізацію fixedThreadPool. Цей клас створює фіксовану кількість потоків і використовуючи цю обмежену кількість по черзі виконує всі поставлені в чергу задачі.
Для створення обєкту використовуємо такий метод
ExecutorService executor = Executors.newFixedThreadPool(2);
параметр вказує кількість потоків, які буде запущено. А постановка задачі в чергу виконується командою
executor.execute(task);

[7controller.java]
[7windows.png]

У цьому варіанті програми виконується не більше двох задач одночасно. Інші очікують своєї черги.